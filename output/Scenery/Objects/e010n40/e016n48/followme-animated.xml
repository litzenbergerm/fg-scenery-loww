<?xml version="1.0" encoding="UTF-8" ?>

<PropertyList>

<!-- airport scenery model for the Flightgear flight simulator.

This program is free software: you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software Foundation, 
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT 
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General 
Public License for more details.

-->
<nasal>
 <load> 
     
     <![CDATA[
     var coords = [16.54130096,48.12315598,169.3443,16.54219077,48.12286270,169.5656,16.54375908,48.12235546,170.0071,16.54421381,48.12231690,170.0494,16.54444721,48.12238773,169.9888,16.54478313,48.12294322,169.4854,16.54505955,48.12303149,169.4121,16.54581813,48.12307453,169.3900,16.54759936,48.12252943,169.9571,16.55117069,48.12139024,171.3914,16.55153239,48.12142245,171.3880,16.55223209,48.12227883,170.5330,16.55267828,48.12231067,170.6122,16.55541323,48.12196623,171.1657,16.55859732,48.12082845,172.7977,16.55955013,48.12020199,173.6579,16.56041046,48.11951389,174.6083,16.56113474,48.11909567,175.2145,16.56280411,48.11849612,176.1340,16.56379804,48.11855832,176.1234,16.56415277,48.11867091,176.0013,16.56521219,48.11854848,176.2220,16.56980807,48.11705570,178.1874,16.57015583,48.11681688,178.4717,16.56966178,48.11615356,179.3167,];
     
     var n1=size(coords);
     var legs = [];
     var speed = 60/3.6;
     var turnspeed = 30/3.6;
     var from = geo.Coord.new().set_latlon(coords[1],coords[0],coords[2]);
     var x=0;var y=0;var z=0;var angle=0;var length=0;
     var to = geo.Coord.new();
     
     #compute all legs of track:
     
     for(var i=3; i<n1; i=i+3) {
         to.set_latlon(coords[i+1],coords[i],coords[i+2]);
         length = to.distance_to(from);
         angle = 90 - from.course_to(to); # heading to angle
        
         append(legs, [ math.sin(angle*D2R)*length, math.cos(angle*D2R)*length, to.alt() - from.alt(), speed ]);
         from.set_latlon(coords[i+1],coords[i],coords[i+2]); #from = to !
     }    

     var duration = 0;
     var n = size(legs)-1;
     var track = [];
     var dir=0;var dir2=0;
     var turnradius=20;
     
     foreach(var ll; legs) {
         x += ll[0];
         y += ll[1];
         z += ll[2];
         length = math.sqrt( ll[0]*ll[0]+ll[1]*ll[1] );
         dir = -math.atan2(ll[1], ll[0])*R2D;                 
         duration += length/ll[3];
         append(track, [x, y, z, length / ll[3], dir, turnradius / ll[3]]);
     }
     
     var nextmove = func (j) {
         var dt = track[j][3];
         var curdir = getprop("sim/scenery/followme/dir-deg") or 0;
         var ddir = math.abs(track[j][4] - curdir);
         
         if (j==0) {
             setprop("sim/scenery/followme/travel-x-m", 0);
             setprop("sim/scenery/followme/travel-y-m", 0);
             setprop("sim/scenery/followme/up-m", 0);
             setprop("sim/scenery/followme/dir-deg", 0);
             setprop("sim/scenery/followme/roll-deg", 0);
         }
         
         interpolate("sim/scenery/followme/travel-x-m", track[j][0], dt);
         interpolate("sim/scenery/followme/travel-y-m", track[j][1], dt);
         interpolate("sim/scenery/followme/up-m", track[j][2], dt);
         
         # turn direction and turn time 
         if (ddir > 180) {
             # handle problem with sign change in direction, no turns > 180         
             if (curdir<0) {
                  setprop("sim/scenery/followme/dir-deg", 360+curdir);
                  interpolate("sim/scenery/followme/dir-deg", track[j][4], track[j][5]);
             } else if (track[j][4] < 0) {
                  interpolate("sim/scenery/followme/dir-deg", 360+track[j][4], track[j][5]);
             }
         } else {
             interpolate("sim/scenery/followme/dir-deg", track[j][4], track[j][5]);
         }
         
         #roll in turn an back
         #setprop("sim/scenery/followme/roll-deg", 10);
         #interpolate("sim/scenery/followme/roll-deg", 0, track[j][5]);
         
         if (j<n) 
             settimer(func {nextmove(j+1);}, dt);          
         else    
             settimer(func {nextmove(0);}, dt+1.0);          
     };
     
     nextmove(0);
     
     ]]>
 </load>
 <unload>
 </unload>
 
</nasal>
    
<path>followme-animated.ac</path>

<!--<animation>
    <type>rotate</type>
    <object-name>Cube</object-name>
    <property>sim/scenery/followme/roll-deg</property>
    <axis>
       <x>1</x>
       <y>0</y>
       <z>0</z>
    </axis>    
</animation>-->

<animation>
    <type>translate</type>
    <object-name>Cube</object-name>
    <property>sim/scenery/followme/travel-x-m</property>
    <axis>
       <x>-1</x>
       <y>0</y>
       <z>0</z>
    </axis>    
</animation>

<animation>
    <type>translate</type>
    <object-name>Cube</object-name>
    <property>sim/scenery/followme/travel-y-m</property>
    <axis>
       <x>0</x>
       <y>1</y>
       <z>0</z>
    </axis>    
</animation>

<animation>
    <type>translate</type>
    <object-name>Cube</object-name>
    <property>sim/scenery/followme/up-m</property>
    <axis>
       <x>0</x>
       <y>0</y>
       <z>1</z>
    </axis>    
</animation>

<animation>
    <type>rotate</type>
    <object-name>Cube</object-name>
    <property>sim/scenery/followme/dir-deg</property>
    <axis>
       <x>0</x>
       <y>0</y>
       <z>1</z>
    </axis>    
</animation>

</PropertyList>
